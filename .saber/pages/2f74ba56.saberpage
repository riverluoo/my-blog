{"page":{"attributes":{"slug":"concurrent/Java-vm","title":"java虚拟机","date":"2018-10-09","layout":"post","excerpt":"<p><img src=\"https://riverluooo.oss-cn-beijing.aliyuncs.com/jvm/540631a4-6018-40a5-aed7-081e2eeeaeea.png\" alt=\"\"></p>\n","createdAt":"2018-10-09T00:00:00.000Z","updatedAt":"2019-04-03T02:25:50.527Z","type":"post","permalink":"/posts/concurrent/Java-vm.html"},"internal":{"id":"2f74ba56","absolute":"/root/src/my-blog/pages/_posts/concurrent/Java-vm.md","relative":"_posts/concurrent/Java-vm.md","isFile":true,"hoistedTags":[],"saved":false},"contentType":"markdown","content":"<h1 id=\"%E4%B8%80%E3%80%81-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F\">一、 运行时数据区域</h1>\n<p><img src=\"https://riverluooo.oss-cn-beijing.aliyuncs.com/jvm/540631a4-6018-40a5-aed7-081e2eeeaeea.png\" alt=\"\"></p>\n<h2 id=\"%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8\">程序计数器</h2>\n<p>Program Counter Register 如果正在执行的是一个Java方法，记录的是正在执行的虚拟机字节码指令的地址; 如果是Native方法，则为空</p>\n<h2 id=\"%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88\">虚拟机栈</h2>\n<p>Virtual Machine Stacks 是线程私有的，生命周期和线程相同，每个方法在执行的同时，都会创建一个栈帧用于存放局部变量表，操作数栈，动态链接，方法出口等信息。每个方法从调用直至完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p>\n<p>该区域可能抛出以下两种异常：</p>\n<ul>\n<li>当线程请求的栈深度大于虚拟机所允许的深度，会抛出StackOverflowError异常</li>\n<li>虚拟机栈可以动态扩展时无法申请到足够的内存，会抛出OutOfMemoryError异常</li>\n</ul>\n<h2 id=\"%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88\">本地方法栈</h2>\n<p>Native Method  Stack 为虚拟机使用的Native方法服务</p>\n<h2 id=\"%E5%A0%86\">堆</h2>\n<p>所有的对象实例都在这里分配内存。</p>\n<p>是垃圾收集的主要区域，也叫做“GC堆”，现在的收集器基本上都是采用分代手机算法，可以将堆分为三块：</p>\n<ul>\n<li>\n<p>新生代</p>\n</li>\n<li>\n<p>老年代</p>\n<p>新生代还可以分为三的空间：</p>\n</li>\n<li>\n<p>Eden 空间</p>\n</li>\n<li>\n<p>From Survivor 空间</p>\n</li>\n<li>\n<p>To Survivor 空间</p>\n</li>\n</ul>\n<p>无论如何划分，都与存放内容无关，无论哪个区域，存放的仍是对象实例</p>\n<p>Java 堆可以处于物理上不连续的内存空间中，只要逻辑上连续即可，可以动态增加内存，增加失败时，会抛出OutOfMemoryError</p>\n<p>可以通过修改初始值-Xms和最大值-Xmx两个参数来指定一盒java堆的内存大小，</p>\n<div class=\"saber-highlight\" v-pre=\"\" data-lang=\"\"><pre class=\"saber-highlight-code\"><code class=\"\">java -Xms=1M -Xmx=2M HackTheJava</code></pre></div><h2 id=\"%E6%96%B9%E6%B3%95%E5%8C%BA\">方法区</h2>\n<p>在hotSpot虚拟机上，很多人愿意把方法区称为“永久代”（Permanent Generation）,但两者并不等价，仅仅是hotSport虚拟机用永久代来实现方法区。在JDK1.7以前，HotSpot把它当永久代进行垃圾回收，在JDK1.8之后，取消的永久代，用metaspace(元数据)区代替。</p>\n<p>用于存放已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据</p>\n<p>和java堆内存一样不需要连续的内存，并且可以动态扩展，无法满足内存分配需求时，将会抛出OutOfMemoryError异常。</p>\n<p>对这一块的垃圾回收的目标主要是针对常量池的回收和对类型的卸载</p>\n<h2 id=\"%E8%BF%90%E8%A1%8C%E5%B8%B8%E9%87%8F%E6%B1%A0\">运行常量池</h2>\n<p>Runtime Constant Pool 是方法区的一部分</p>\n<p>存放编译器生成的各种字面量和符号饮用，会在类加载进去方法区的的时候放入这个区域</p>\n<p>除了编译器生成的常量，还可以动态生成</p>\n<h2 id=\"%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98\">直接内存</h2>\n<p>Direct Memory并不是虚拟机运行时数据区的一部分，也不是java虚拟机规范中定义的内存区域，但这部分区域也被频繁的使用。</p>\n<p>在JDK1.4中加入了NIO类，他可以直接使用Native函数库直接分配堆外内存，然后通过存储在堆中的DirectByteBuffer对象作为这块内存的引用进行操作。</p>\n<p>进行动态扩展时也会出现OutOfMemoryError异常</p>\n<h1 id=\"%E4%BA%8C%E3%80%81-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E8%B1%A1\">二、 虚拟机对象</h1>\n<p>虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能够在常量池中定位到一个类的符号引用，并且检查这个符号引用的类是否已被加载，解析和初始化。</p>\n<h2 id=\"%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80\">对象的内存布局</h2>\n<p>对象在内存中的布局可以分为3块区域</p>\n<ul>\n<li>对象头（Header）</li>\n<li>实例数据 （Instance Data）</li>\n<li>对齐填充 （Padding）</li>\n</ul>\n<h2 id=\"%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D\">对象的访问定位</h2>\n<p>句柄访问 ：java堆将会划分出来一块内存来作为句柄池，reference中存储的就是对象的句柄地址。</p>\n<p><img src=\"https://riverluooo.oss-cn-beijing.aliyuncs.com/jvm/WX20180707-184919.png\" alt=\"\"></p>\n<p>直接指针访问：refercnce中存储的直接就是对象地址</p>\n<p><img src=\"https://riverluooo.oss-cn-beijing.aliyuncs.com/jvm/WX20180707-185154.png\" alt=\"\"></p>\n<p>使用直接指针访问的方式速度更快，节省了一次指针定位的时间开销</p>\n<h2 id=\"java-%E5%A0%86%E6%BA%A2%E5%87%BA\">java 堆溢出</h2>\n<p>只要不断的创造对象，并且保证GC Roots到达对象之间有可达的路径来避免垃圾回收机制来清除这些对象，在对象数量达到堆的最大的容量限制后就会产生内存溢出异常。</p>\n<ul>\n<li>内存泄露 (Memory Leak)</li>\n<li>内存溢出 (Memory OverFlow)</li>\n</ul>\n<h2 id=\"%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%92%8C%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E5%8C%BA%E6%A0%88%E6%BA%A2%E5%87%BA\">虚拟机栈和本地方法区栈溢出</h2>\n<p>如果线程请求的栈深度大于虚拟机所允许的最大深度，将会抛出StackOverFlowError</p>\n<p>如果虚拟栈在扩展栈时无法获取到足够的内存空间，将会抛出OutOfMemoryError</p>\n<h2 id=\"%E6%96%B9%E6%B3%95%E5%8C%BA%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E5%B8%B8%E9%87%8F%E6%B1%A0%E6%BA%A2%E5%87%BA\">方法区和运行时的常量池溢出</h2>\n<p>一个类要被垃圾收集器回收掉，判定条件时比较苛刻的</p>\n<p>在经常动态生成大了的Class的应用中，需要注意类的回收情况</p>\n<h1 id=\"%E4%B8%89%E3%80%81-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86\">三、 垃圾收集</h1>\n<h2 id=\"%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%AD%98%E6%B4%BB\">判断一个对象是否存活</h2>\n<h3 id=\"1%EF%BC%9A%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95\">1：引用计数法</h3>\n<h3 id=\"2%3A-%E5%8F%AF%E8%BE%BE%E6%80%A7%E7%AE%97%E6%B3%95\">2:  可达性算法</h3>\n<h3 id=\"3%EF%BC%9A%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B\">3：引用类型</h3>\n<p><strong>强引用</strong></p>\n<p><strong>软引用</strong></p>\n<p><strong>弱引用</strong></p>\n<p><strong>虚引用</strong></p>\n<h3 id=\"4%3A-%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%9B%9E%E6%94%B6\">4: 方法区的回收</h3>\n<h2 id=\"%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95\">垃圾收集算法</h2>\n<h3 id=\"1%3A-%E6%A0%87%E8%AE%B0---%E6%B8%85%E9%99%A4\">1: 标记 - 清除</h3>\n<h3 id=\"2-%EF%BC%9A%E6%A0%87%E8%AE%B0---%E6%95%B4%E7%90%86\">2 ：标记 - 整理</h3>\n<h3 id=\"3-%EF%BC%9A%E5%A4%8D%E5%88%B6\">3 ：复制</h3>\n<h3 id=\"4-%EF%BC%9A%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86\">4 ：分代收集</h3>\n<h2 id=\"%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8\">垃圾收集器</h2>\n<h3 id=\"1-%3A-serial-%E6%94%B6%E9%9B%86%E5%99%A8\">1 : Serial 收集器</h3>\n<h3 id=\"2-%EF%BC%9Aparnew-%E6%94%B6%E9%9B%86%E5%99%A8\">2 ：ParNew 收集器</h3>\n<h3 id=\"3-%3A-parallel-scavenge-%E6%94%B6%E9%9B%86%E5%99%A8\">3 :  Parallel Scavenge 收集器</h3>\n<h3 id=\"4-%EF%BC%9Aserial-old-%E6%94%B6%E9%9B%86%E5%99%A8\">4 ：Serial Old 收集器</h3>\n<h3 id=\"5-%EF%BC%9Aparallel-old-%E6%94%B6%E9%9B%86%E5%99%A8\">5 ：Parallel Old 收集器</h3>\n<h3 id=\"6-%EF%BC%9Acms-%E6%94%B6%E9%9B%86%E5%99%A8\">6 ：CMS 收集器</h3>\n<h3 id=\"7-%EF%BC%9Ag1-%E6%94%B6%E9%9B%86%E5%99%A8\">7 ：G1 收集器</h3>\n<h2 id=\"%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5\">内存分配和回收策略</h2>\n<h3 id=\"1-%3A-minor-gc-%E5%92%8C-full-gc\">1 : Minor GC 和 Full GC</h3>\n<h3 id=\"2-%3A-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D\">2 : 内存分配</h3>\n<h3 id=\"3-%EF%BC%9Afucc-gc-%E7%9A%84%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6\">3 ：Fucc GC 的触发条件</h3>\n<h1 id=\"%E5%9B%9B%E3%80%81-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7\">四、 虚拟机性能监控</h1>\n<h2 id=\"jdk%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7\">JDK命令行工具</h2>\n<p>jps</p>\n<ul>\n<li>-q</li>\n<li>-m</li>\n<li>-l</li>\n<li>-v</li>\n</ul>\n<h1 id=\"%E4%BA%94%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6\">五、类加载机制</h1>\n<h2 id=\"%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F\">类的生命周期</h2>\n<ul>\n<li>加载（Loading）</li>\n<li>验证 （Verification）</li>\n<li>准备 (Preparation)</li>\n<li>解析 （Resolution）</li>\n<li>初始化 （Initialization）</li>\n<li>使用 （Using）</li>\n<li>卸载 （Unloading）</li>\n</ul>\n<h2 id=\"%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%B6%E6%9C%BA\">类初始化时机</h2>\n<h2 id=\"%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B\">类加载过程</h2>\n<h3 id=\"1%3A%E5%8A%A0%E8%BD%BD\">1:加载</h3>\n<h3 id=\"2%3A%E9%AA%8C%E8%AF%81\">2:验证</h3>\n<h3 id=\"3%3A%E5%87%86%E5%A4%87\">3:准备</h3>\n<h3 id=\"4%3A%E8%A7%A3%E6%9E%90\">4:解析</h3>\n<h3 id=\"5%3A%E5%88%9D%E5%A7%8B%E5%8C%96\">5:初始化</h3>\n<h2 id=\"%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8\">类加载器</h2>\n<h3 id=\"1%3A%E7%B1%BB%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8\">1:类与类加载器</h3>\n<h3 id=\"2%3A-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%88%86%E7%B1%BB\">2: 类加载器分类</h3>\n<h3 id=\"3%3A%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%BC%8F\">3:双亲委派模式</h3>\n"},"prop":{}}