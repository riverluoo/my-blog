{"page":{"attributes":{"slug":"concurrent/Java-concurrent","title":"java并发","date":"2018-10-08","layout":"post","excerpt":"资源利用","createdAt":"2018-10-08T00:00:00.000Z","updatedAt":"2019-04-03T02:25:50.527Z","type":"post","permalink":"/posts/concurrent/Java-concurrent.html"},"internal":{"id":"6904db56","absolute":"/root/src/my-blog/pages/_posts/concurrent/Java-concurrent.md","relative":"_posts/concurrent/Java-concurrent.md","isFile":true,"hoistedTags":[],"saved":false},"contentType":"markdown","content":"<h1 id=\"%E5%B9%B6%E5%8F%91%E7%9A%84%E5%8E%86%E5%8F%B2\">并发的历史</h1>\n<ul>\n<li>资源利用</li>\n<li>公平</li>\n<li>方便</li>\n</ul>\n<h2 id=\"jdk-%E6%8F%90%E4%BE%9B%E7%9A%84%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8\">JDK 提供的并发容器</h2>\n<p>JDK 提供的大部分在 java.util.concurrent 包中</p>\n<ul>\n<li>ConcurrentHashMap：线程安全的 HashMap</li>\n<li>CopyOnWirteArrayList : 线程安全的 list,在读多写少的情况下，性能非常好</li>\n<li>ConcurrentLinkedQueue ：高效的并发队列，使用链表实习，可以看作一个线程安全的 LinkedList</li>\n<li>ConcurrentSkipListMap : 是一个 map 使用跳表的数据结构进行快速查找</li>\n</ul>\n<h2 id=\"concurrenthashmap\">ConcurrentHashMap</h2>\n<p>我们知道 HashMap 不是线程安全的，在并发场景下如果要保证一种可行的方法使用\nCollection.synchronizedMap() 方法来包装 HashMap，但这种通过使用一个全局的同步不同线程间的并发访问，\n会带来不可忽视的性能问题</p>\n<p>以此 有了 ConcurrentHashMap ,在 concurrentHashMap 中，无论是连续的读操作还是写操作\n都能保证很高的性能。在进行读操作不需要加锁，在写操作时通过锁分段技术只对所操作的段加锁而不影响其他的访问</p>\n<h3 id=\"concurrenthashmap-%E7%9A%84%E5%AE%9E%E7%8E%B0\">ConcurrentHashMap 的实现</h3>\n<ul>\n<li>jdk1.7\n首先将数据分为一段一段的存储,然后给每一段数据加一把锁，当一个线程占用锁访问其中一个断数据时\n其他段数据也能被其他线程访问,CoucurrentHashMap 由 Segment 数组结构和 HashEntry 数组结构组成\nSegment 是一种可重入锁 ReentrantLock,在 ConcurrentHashMap 中扮演锁的角色\nHashEntry 用于存储键值对数据,一个 ConcurrentHashMap 里包含一个 Segment 数组，Segment 结构和 HashMap 类似\n是一种数组和链表的结构,一个 Segment 数组包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，\n每个 Segment 守护着一个 HashEntry 数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得它对应的 Segment 锁</li>\n</ul>\n<div class=\"saber-highlight\" v-pre=\"\" data-lang=\"java\"><pre class=\"saber-highlight-code language-java\"><code class=\"language-java\">static class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable {\n}</code></pre></div><p><img src=\"https://riverluooo.oss-cn-beijing.aliyuncs.com/img/20181219221241.png\" alt=\"\"></p>\n<ul>\n<li>jdk1.8</li>\n</ul>\n<p>ConcurrentHashMap取消了Segment分段锁，采用CAS和synchronized来保证并发安全。\n数据结构跟HashMap1.8的结构类似，数组+链表/红黑二叉树</p>\n<p>synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发</p>\n<p><img src=\"https://riverluooo.oss-cn-beijing.aliyuncs.com/img/20181219221700.png\" alt=\"\"></p>\n"},"prop":{}}